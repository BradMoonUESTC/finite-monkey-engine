"""Economic Exploit Detector for Smart Contract Security Analysis.

This module provides comprehensive detection for 25+ economic exploit types,
including both low-hanging fruit vulnerabilities and deep logic/economic exploits.
"""

import re
from dataclasses import dataclass
from enum import Enum
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple


class ExploitSeverity(Enum):
    """Severity levels for economic exploits."""

    CRITICAL = "critical"  # $500K+ potential loss
    HIGH = "high"  # $100K-$500K potential loss
    MEDIUM = "medium"  # $10K-$100K potential loss
    LOW = "low"  # $1K-$10K potential loss
    INFO = "info"  # Informational finding


class ExploitCategory(Enum):
    """Categories of economic exploits."""

    LOW_HANGING_FRUIT = "low_hanging_fruit"  # $5K-$250K bugs
    DEEP_LOGIC = "deep_logic"  # $500K-$10M+ bugs
    PROTOCOL_SPECIFIC = "protocol_specific"  # Protocol-specific issues
    CROSS_PROTOCOL = "cross_protocol"  # Cross-protocol composability issues


@dataclass
class ExploitPattern:
    """Pattern definition for exploit detection."""

    name: str
    category: ExploitCategory
    severity: ExploitSeverity
    description: str
    patterns: List[str]  # Regex patterns to match
    indicators: List[str]  # Code indicators
    mitigation: str
    potential_loss_range: str


@dataclass
class ExploitFinding:
    """A detected exploit finding."""

    exploit_type: str
    severity: ExploitSeverity
    category: ExploitCategory
    description: str
    location: str
    code_snippet: str
    confidence: float  # 0.0 to 1.0
    potential_impact: str
    mitigation: str
    references: List[str]


class EconomicExploitDetector:
    """Detect advanced economic exploits in smart contracts.

    This detector identifies 25+ exploit types including:

    LOW-HANGING FRUIT ($5K-$250K bugs):
    1. Unchecked external call returns
    2. Missing access control on critical functions
    3. Reentrancy (ERC-777/read-only variants)
    4. Signature replay (EIP-2612, EIP-1271, cross-chain)
    5. Uninitialized/double-initialize proxies
    6. Delegatecall in upgradable contracts
    7. Blockhash/timestamp dependence
    8. tx.origin authentication
    9. ERC20 approve race conditions
    10. Missing slippage/deadline checks
    11. Fee-on-transfer token accounting bugs
    12. Emergency withdraw without timelock
    13. Hard-coded addresses
    14. Selfdestruct in libraries/proxies
    15. Incorrect decimals handling

    DEEP LOGIC/ECONOMIC EXPLOITS ($500K-$10M+ bugs):
    1. Flash Loan Oracle Manipulation
    2. Governance Flash-Vote Attacks
    3. Vault Share Inflation via Donation
    4. Cross-Protocol Composability Exploits
    5. MEV/Sandwich Attacks
    6. Proxy Storage Collision
    7. TWAP Oracle Window Attacks
    8. Logical Reentrancy via ERC-777/1155 Hooks
    9. Forced Ether Injection via SELFDESTRUCT
    10. Read-Only Reentrancy
    11. Permit/EIP-712 Signature Malleability
    12. Bridge Replay Attacks
    13. Rounding Drift/Precision Loss
    14. Griefing via Spam
    15. Emergency Pause Bypass
    16. Flash-Mint Token Exploits
    17. Rebase Token + Snapshot Timing Attacks
    18. Multicall Double-Spend
    19. Profit Cap Bypass via Partial Closes
    20. Funding Rate Drain
    21. Leverage Clamping Bypass
    22. Loss Socialization Token Inflation
    23. Bridge Verifier Logic Flaws
    24. Arbitrary Call Dispatch in Cross-Chain Gateways
    """

    # Low-Hanging Fruit Exploit Patterns
    LOW_HANGING_PATTERNS: List[ExploitPattern] = [
        ExploitPattern(
            name="unchecked_external_call",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.HIGH,
            description="Unchecked external call return value can lead to silent failures",
            patterns=[
                r"\.call\{.*?\}\s*\([^;]*\)\s*;",  # call without checking return
                r"\.delegatecall\s*\([^;]*\)\s*;",  # delegatecall without check
                r"\.staticcall\s*\([^;]*\)\s*;",  # staticcall without check
            ],
            indicators=["call", "delegatecall", "staticcall", "transfer", "send"],
            mitigation="Always check return values from external calls or use SafeCall patterns",
            potential_loss_range="$5K-$50K",
        ),
        ExploitPattern(
            name="missing_access_control",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.CRITICAL,
            description="Missing access control on critical functions",
            patterns=[
                r"function\s+\w+\s*\([^)]*\)\s*(?:public|external)(?!\s+(?:view|pure))[^{]*\{",
                r"function\s+(?:set|update|change|modify|admin|owner)\w*\s*\([^)]*\)\s*(?:public|external)",
            ],
            indicators=["onlyOwner", "onlyAdmin", "require(msg.sender", "modifier"],
            mitigation="Add proper access control modifiers (onlyOwner, onlyAdmin, role-based)",
            potential_loss_range="$50K-$250K",
        ),
        ExploitPattern(
            name="reentrancy",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.CRITICAL,
            description="Reentrancy vulnerability including ERC-777/ERC-1155 hook variants",
            patterns=[
                r"\.call\{value:",  # Value transfer followed by state change
                r"transfer\s*\(",  # transfer before state update
                r"safeTransferFrom\s*\(",  # ERC-721/1155 hooks
            ],
            indicators=["nonReentrant", "ReentrancyGuard", "_status", "mutex"],
            mitigation="Use ReentrancyGuard or checks-effects-interactions pattern",
            potential_loss_range="$50K-$500K",
        ),
        ExploitPattern(
            name="signature_replay",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.HIGH,
            description="Signature replay vulnerability (missing nonce, chain_id, or expiry)",
            patterns=[
                r"ecrecover\s*\(",
                r"ECDSA\.recover\s*\(",
                r"SignatureChecker\.",
            ],
            indicators=["nonce", "deadline", "chainId", "block.chainid", "expiry"],
            mitigation="Include nonce, chainId, deadline in signed messages; use EIP-712",
            potential_loss_range="$10K-$100K",
        ),
        ExploitPattern(
            name="uninitialized_proxy",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.CRITICAL,
            description="Uninitialized or double-initialized proxy vulnerability",
            patterns=[
                r"function\s+initialize\s*\(",
                r"initializer\s+\{",
                r"Initializable",
            ],
            indicators=["initializer", "initialized", "_disableInitializers", "onlyInitializing"],
            mitigation="Use OpenZeppelin Initializable with proper guards",
            potential_loss_range="$100K-$500K",
        ),
        ExploitPattern(
            name="delegatecall_in_upgradable",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.CRITICAL,
            description="Unsafe delegatecall in upgradable contracts",
            patterns=[
                r"delegatecall\s*\(",
                r"\.delegatecall\s*\{",
            ],
            indicators=["_implementation", "upgradeTo", "UUPS", "TransparentProxy"],
            mitigation="Restrict delegatecall targets and validate implementation addresses",
            potential_loss_range="$100K-$1M",
        ),
        ExploitPattern(
            name="block_dependency",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.MEDIUM,
            description="Blockhash or timestamp dependence for randomness/timing",
            patterns=[
                r"blockhash\s*\(",
                r"block\.timestamp",
                r"block\.number",
            ],
            indicators=["randomness", "lottery", "raffle", "random"],
            mitigation="Use Chainlink VRF for randomness; add time buffers for timing",
            potential_loss_range="$5K-$50K",
        ),
        ExploitPattern(
            name="tx_origin_auth",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.HIGH,
            description="Using tx.origin for authentication is vulnerable to phishing",
            patterns=[
                r"tx\.origin\s*==",
                r"require\s*\(\s*tx\.origin",
            ],
            indicators=["msg.sender", "tx.origin"],
            mitigation="Always use msg.sender for authentication instead of tx.origin",
            potential_loss_range="$10K-$100K",
        ),
        ExploitPattern(
            name="erc20_approve_race",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.MEDIUM,
            description="ERC20 approve race condition vulnerability",
            patterns=[
                r"function\s+approve\s*\(",
                r"\.approve\s*\(",
            ],
            indicators=["increaseAllowance", "decreaseAllowance", "safeApprove", "forceApprove"],
            mitigation="Use increaseAllowance/decreaseAllowance or set to 0 first",
            potential_loss_range="$5K-$25K",
        ),
        ExploitPattern(
            name="missing_slippage_deadline",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.HIGH,
            description="Missing slippage protection or deadline in DEX operations",
            patterns=[
                r"swap\w*\s*\(",
                r"addLiquidity\s*\(",
                r"removeLiquidity\s*\(",
            ],
            indicators=["minAmountOut", "deadline", "slippage", "amountOutMin"],
            mitigation="Add user-defined slippage tolerance and transaction deadline",
            potential_loss_range="$10K-$100K",
        ),
        ExploitPattern(
            name="fee_on_transfer_bug",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.MEDIUM,
            description="Fee-on-transfer token accounting bugs",
            patterns=[
                r"transferFrom\s*\([^)]+\)",
                r"safeTransferFrom\s*\([^)]+\)",
            ],
            indicators=["balanceOf", "balanceBefore", "balanceAfter", "received"],
            mitigation="Check actual received amount using balanceBefore/balanceAfter pattern",
            potential_loss_range="$5K-$50K",
        ),
        ExploitPattern(
            name="emergency_withdraw_no_timelock",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.HIGH,
            description="Emergency withdraw without timelock allows instant rug pulls",
            patterns=[
                r"function\s+emergency\w*\s*\(",
                r"function\s+rescue\w*\s*\(",
            ],
            indicators=["timelock", "delay", "TimelockController", "minDelay"],
            mitigation="Add timelock for emergency functions or multi-sig requirements",
            potential_loss_range="$50K-$250K",
        ),
        ExploitPattern(
            name="hardcoded_addresses",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.MEDIUM,
            description="Hard-coded addresses may cause issues across chains/upgrades",
            patterns=[
                r"0x[a-fA-F0-9]{40}",
                r"address\s+constant\s+\w+\s*=\s*0x",
            ],
            indicators=["immutable", "constant", "constructor", "initialize"],
            mitigation="Use constructor/initializer parameters or chain-specific configs",
            potential_loss_range="$5K-$25K",
        ),
        ExploitPattern(
            name="selfdestruct_vulnerability",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.CRITICAL,
            description="Selfdestruct in libraries/proxies can destroy implementations",
            patterns=[
                r"selfdestruct\s*\(",
                r"suicide\s*\(",
            ],
            indicators=["selfdestruct", "suicide", "delegatecall"],
            mitigation="Avoid selfdestruct in upgradeable/library contracts",
            potential_loss_range="$100K-$1M",
        ),
        ExploitPattern(
            name="incorrect_decimals",
            category=ExploitCategory.LOW_HANGING_FRUIT,
            severity=ExploitSeverity.MEDIUM,
            description="Incorrect decimals handling can cause calculation errors",
            patterns=[
                r"decimals\s*\(\s*\)",
                r"\*\s*10\s*\*\*\s*\d+",
                r"/\s*10\s*\*\*\s*\d+",
            ],
            indicators=["decimals", "1e18", "10**18", "normalize"],
            mitigation="Always query decimals dynamically; normalize to consistent precision",
            potential_loss_range="$10K-$100K",
        ),
    ]

    # Deep Logic/Economic Exploit Patterns
    DEEP_LOGIC_PATTERNS: List[ExploitPattern] = [
        ExploitPattern(
            name="flash_loan_oracle_manipulation",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.CRITICAL,
            description="Flash loan oracle price manipulation for profit extraction",
            patterns=[
                r"flashLoan\s*\(",
                r"IFlashLoanReceiver",
                r"executeOperation\s*\(",
                r"onFlashLoan\s*\(",
            ],
            indicators=["getPrice", "latestAnswer", "getReserves", "slot0", "observe"],
            mitigation="Use TWAP oracles, add manipulation checks, limit max price deviation",
            potential_loss_range="$500K-$10M+",
        ),
        ExploitPattern(
            name="governance_flash_vote",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.CRITICAL,
            description="Flash loan to temporarily gain voting power for governance attacks",
            patterns=[
                r"delegate\s*\(",
                r"castVote\s*\(",
                r"propose\s*\(",
            ],
            indicators=["checkpoint", "snapshot", "getPriorVotes", "getPastVotes"],
            mitigation="Use voting snapshots from past blocks; add vote escrow periods",
            potential_loss_range="$1M-$10M+",
        ),
        ExploitPattern(
            name="vault_share_inflation",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="First depositor/donation attack to inflate vault shares",
            patterns=[
                r"function\s+deposit\s*\(",
                r"convertToShares\s*\(",
                r"previewDeposit\s*\(",
            ],
            indicators=["totalAssets", "totalSupply", "virtualOffset", "_decimalsOffset"],
            mitigation="Use virtual shares offset (ERC-4626) or minimum deposit amounts",
            potential_loss_range="$100K-$1M",
        ),
        ExploitPattern(
            name="cross_protocol_exploit",
            category=ExploitCategory.CROSS_PROTOCOL,
            severity=ExploitSeverity.CRITICAL,
            description="Cross-protocol composability exploits through unexpected interactions",
            patterns=[
                r"interface\s+I\w+",
                r"\.call\s*\{",
                r"external\s+returns",
            ],
            indicators=["callback", "hook", "flash", "borrow"],
            mitigation="Validate external protocol states; use reentrancy guards across protocols",
            potential_loss_range="$500K-$5M",
        ),
        ExploitPattern(
            name="mev_sandwich",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="MEV sandwich attack vulnerability in swap operations",
            patterns=[
                r"swap\w*\s*\(",
                r"getAmountOut\s*\(",
                r"getAmountsOut\s*\(",
            ],
            indicators=["slippage", "deadline", "minAmountOut", "private", "flashbots"],
            mitigation="Use private mempools, add strict slippage, implement commit-reveal",
            potential_loss_range="$10K-$500K",
        ),
        ExploitPattern(
            name="proxy_storage_collision",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.CRITICAL,
            description="Storage collision between proxy and implementation contracts",
            patterns=[
                r"delegatecall\s*\(",
                r"ERC1967Upgrade",
                r"StorageSlot\.",
            ],
            indicators=["slot", "storage", "keccak256", "IMPLEMENTATION_SLOT"],
            mitigation="Use EIP-1967 storage slots; avoid storage in base contracts",
            potential_loss_range="$100K-$5M",
        ),
        ExploitPattern(
            name="twap_window_attack",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="TWAP oracle manipulation through window timing attacks",
            patterns=[
                r"observe\s*\(",
                r"consult\s*\(",
                r"getTimeWeightedAveragePrice\s*\(",
            ],
            indicators=["period", "window", "interval", "observation"],
            mitigation="Use longer TWAP windows; add price deviation checks",
            potential_loss_range="$100K-$2M",
        ),
        ExploitPattern(
            name="read_only_reentrancy",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="Read-only reentrancy through view function exploitation",
            patterns=[
                r"function\s+\w+\s*\([^)]*\)\s*(?:public|external)\s+view",
                r"balanceOf\s*\(",
                r"getReserves\s*\(",
            ],
            indicators=["view", "staticcall", "getPrice", "totalAssets"],
            mitigation="Use reentrancy guards on view functions accessing external state",
            potential_loss_range="$100K-$1M",
        ),
        ExploitPattern(
            name="forced_ether_injection",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.MEDIUM,
            description="Forced ETH injection via selfdestruct breaks accounting",
            patterns=[
                r"address\s*\(\s*this\s*\)\.balance",
                r"selfdestruct\s*\(",
            ],
            indicators=["balance", "deposited", "totalDeposits", "accounting"],
            mitigation="Track deposits separately; don't rely on contract balance",
            potential_loss_range="$10K-$100K",
        ),
        ExploitPattern(
            name="signature_malleability",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="EIP-712/Permit signature malleability vulnerabilities",
            patterns=[
                r"permit\s*\(",
                r"DOMAIN_SEPARATOR",
                r"_useNonce\s*\(",
            ],
            indicators=["s", "v", "r", "ecrecover", "ECDSA"],
            mitigation="Use OpenZeppelin ECDSA with s-value checks; validate signature uniqueness",
            potential_loss_range="$50K-$500K",
        ),
        ExploitPattern(
            name="bridge_replay",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.CRITICAL,
            description="Cross-chain bridge message replay attacks",
            patterns=[
                r"onMessage\s*\(",
                r"receiveMessage\s*\(",
                r"executeMessage\s*\(",
            ],
            indicators=["nonce", "sourceChainId", "processed", "executed"],
            mitigation="Track processed message hashes; include chainId in messages",
            potential_loss_range="$1M-$100M+",
        ),
        ExploitPattern(
            name="precision_loss",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.MEDIUM,
            description="Rounding drift and precision loss in calculations",
            patterns=[
                r"/\s*\w+\s*\*",  # Division before multiplication
                r"\*\s*\w+\s*/\s*\w+\s*/",  # Multiple divisions
            ],
            indicators=["precision", "rounding", "dust", "remainder"],
            mitigation="Multiply before divide; use higher precision intermediates",
            potential_loss_range="$10K-$100K",
        ),
        ExploitPattern(
            name="griefing_attack",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.MEDIUM,
            description="Griefing via spam or dust to exhaust gas/block resources",
            patterns=[
                r"for\s*\([^)]*;\s*[^)]*;\s*[^)]*\)\s*\{",
                r"while\s*\([^)]*\)\s*\{",
            ],
            indicators=["length", "array", "mapping", "iteration"],
            mitigation="Limit array sizes; use pagination; implement gas limits",
            potential_loss_range="$1K-$50K",
        ),
        ExploitPattern(
            name="pause_bypass",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="Emergency pause bypass through alternative code paths",
            patterns=[
                r"whenNotPaused",
                r"require\s*\(\s*!paused",
                r"Pausable",
            ],
            indicators=["paused", "pause", "unpause", "emergency"],
            mitigation="Apply pause checks consistently; audit all entry points",
            potential_loss_range="$100K-$1M",
        ),
        ExploitPattern(
            name="flash_mint_exploit",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="Flash mint token exploits through temporary supply inflation",
            patterns=[
                r"flashMint\s*\(",
                r"flashFee\s*\(",
                r"maxFlashLoan\s*\(",
            ],
            indicators=["totalSupply", "flashLoan", "mint", "burn"],
            mitigation="Limit flash mint amounts; check invariants pre/post flash mint",
            potential_loss_range="$100K-$500K",
        ),
        ExploitPattern(
            name="rebase_snapshot_timing",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="Rebase token + snapshot timing attacks",
            patterns=[
                r"rebase\s*\(",
                r"snapshot\s*\(",
                r"balanceOfAt\s*\(",
            ],
            indicators=["rebase", "elastic", "snapshot", "checkpoint"],
            mitigation="Sync rebases with snapshots; use share-based accounting",
            potential_loss_range="$100K-$500K",
        ),
        ExploitPattern(
            name="multicall_double_spend",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="Multicall batch operation double-spend vulnerabilities",
            patterns=[
                r"multicall\s*\(",
                r"batch\s*\(",
                r"delegatecall\s*\([^)]*\)",
            ],
            indicators=["msg.value", "delegatecall", "this.balance"],
            mitigation="Don't use msg.value in multicall; track value consumption",
            potential_loss_range="$50K-$500K",
        ),
        ExploitPattern(
            name="profit_cap_bypass",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.MEDIUM,
            description="Profit cap bypass via partial position closes",
            patterns=[
                r"closePosition\s*\(",
                r"partialClose\s*\(",
                r"reducePosition\s*\(",
            ],
            indicators=["maxProfit", "profitCap", "pnl", "realized"],
            mitigation="Apply profit caps to each close operation proportionally",
            potential_loss_range="$50K-$200K",
        ),
        ExploitPattern(
            name="funding_rate_drain",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="Funding rate manipulation to drain protocol",
            patterns=[
                r"fundingRate\s*\(",
                r"getFunding\s*\(",
                r"accumulatedFunding",
            ],
            indicators=["funding", "rate", "long", "short", "skew"],
            mitigation="Cap funding rates; use robust rate calculation mechanisms",
            potential_loss_range="$100K-$1M",
        ),
        ExploitPattern(
            name="leverage_clamp_bypass",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.MEDIUM,
            description="Leverage clamping bypass through position manipulation",
            patterns=[
                r"maxLeverage",
                r"leverage\s*>",
                r"setLeverage\s*\(",
            ],
            indicators=["leverage", "margin", "collateral", "position"],
            mitigation="Check leverage after all operations; prevent manipulation sequences",
            potential_loss_range="$50K-$300K",
        ),
        ExploitPattern(
            name="loss_socialization_inflation",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.HIGH,
            description="Loss socialization leading to token inflation",
            patterns=[
                r"socializeLoss\s*\(",
                r"bad[Dd]ebt",
                r"insuranceFund",
            ],
            indicators=["loss", "socialize", "insurance", "deficit"],
            mitigation="Cap socialized losses; maintain adequate insurance reserves",
            potential_loss_range="$100K-$1M",
        ),
        ExploitPattern(
            name="bridge_verifier_flaw",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.CRITICAL,
            description="Bridge verifier logic flaws allowing fake proofs",
            patterns=[
                r"verifyProof\s*\(",
                r"validateMessage\s*\(",
                r"merkleProof",
            ],
            indicators=["proof", "verify", "merkle", "validator"],
            mitigation="Use battle-tested verification; implement multi-validator consensus",
            potential_loss_range="$10M-$100M+",
        ),
        ExploitPattern(
            name="arbitrary_call_dispatch",
            category=ExploitCategory.DEEP_LOGIC,
            severity=ExploitSeverity.CRITICAL,
            description="Arbitrary call dispatch in cross-chain gateways",
            patterns=[
                r"\.call\s*\{[^}]*\}\s*\([^)]*\)",
                r"target\.call\s*\(",
                r"Address\.functionCall",
            ],
            indicators=["gateway", "bridge", "target", "payload"],
            mitigation="Whitelist allowed targets/functions; validate all parameters",
            potential_loss_range="$1M-$50M+",
        ),
    ]

    def __init__(self) -> None:
        """Initialize the economic exploit detector."""
        self.all_patterns = self.LOW_HANGING_PATTERNS + self.DEEP_LOGIC_PATTERNS
        self.findings: List[ExploitFinding] = []

    def detect_all(self, code: str, file_path: str = "") -> List[ExploitFinding]:
        """Detect all known economic exploits in the given code.

        Args:
            code: The source code to analyze
            file_path: Optional file path for location reporting

        Returns:
            List of detected exploit findings
        """
        self.findings = []

        for pattern in self.all_patterns:
            findings = self._detect_pattern(code, pattern, file_path)
            self.findings.extend(findings)

        return self.findings

    def detect_low_hanging_fruit(self, code: str, file_path: str = "") -> List[ExploitFinding]:
        """Detect only low-hanging fruit exploits ($5K-$250K range).

        Args:
            code: The source code to analyze
            file_path: Optional file path for location reporting

        Returns:
            List of detected exploit findings
        """
        findings = []

        for pattern in self.LOW_HANGING_PATTERNS:
            pattern_findings = self._detect_pattern(code, pattern, file_path)
            findings.extend(pattern_findings)

        return findings

    def detect_deep_logic(self, code: str, file_path: str = "") -> List[ExploitFinding]:
        """Detect deep logic and economic exploits ($500K-$10M+ range).

        Args:
            code: The source code to analyze
            file_path: Optional file path for location reporting

        Returns:
            List of detected exploit findings
        """
        findings = []

        for pattern in self.DEEP_LOGIC_PATTERNS:
            pattern_findings = self._detect_pattern(code, pattern, file_path)
            findings.extend(pattern_findings)

        return findings

    def _detect_pattern(self, code: str, pattern: ExploitPattern, file_path: str) -> List[ExploitFinding]:
        """Detect a specific exploit pattern in code.

        Args:
            code: Source code to analyze
            pattern: The exploit pattern to detect
            file_path: File path for location

        Returns:
            List of findings for this pattern
        """
        findings = []
        lines = code.split("\n")

        # Check for pattern matches
        for regex_pattern in pattern.patterns:
            try:
                matches = list(re.finditer(regex_pattern, code, re.MULTILINE | re.IGNORECASE))

                for match in matches:
                    # Calculate line number
                    line_num = code[: match.start()].count("\n") + 1

                    # Get code snippet (context lines)
                    start_line = max(0, line_num - 3)
                    end_line = min(len(lines), line_num + 2)
                    snippet = "\n".join(lines[start_line:end_line])

                    # Check for mitigations (indicators that the issue is already addressed)
                    has_mitigation = self._check_mitigation_indicators(code, pattern.indicators, match.start())

                    # Calculate confidence based on context
                    confidence = self._calculate_confidence(code, pattern, match, has_mitigation)

                    if confidence > 0.3:  # Only report findings with reasonable confidence
                        finding = ExploitFinding(
                            exploit_type=pattern.name,
                            severity=pattern.severity,
                            category=pattern.category,
                            description=pattern.description,
                            location=f"{file_path}:{line_num}" if file_path else f"Line {line_num}",
                            code_snippet=snippet,
                            confidence=confidence,
                            potential_impact=pattern.potential_loss_range,
                            mitigation=pattern.mitigation,
                            references=self._get_references(pattern.name),
                        )
                        findings.append(finding)
            except re.error:
                continue

        return findings

    def _check_mitigation_indicators(self, code: str, indicators: List[str], match_pos: int) -> bool:
        """Check if mitigation indicators are present near the match.

        Args:
            code: Full source code
            indicators: List of indicator strings to check
            match_pos: Position of the pattern match

        Returns:
            True if mitigation indicators found
        """
        # Check within 500 characters of the match
        context_start = max(0, match_pos - 500)
        context_end = min(len(code), match_pos + 500)
        context = code[context_start:context_end].lower()

        for indicator in indicators:
            if indicator.lower() in context:
                return True

        return False

    def _calculate_confidence(
        self, code: str, pattern: ExploitPattern, match: re.Match, has_mitigation: bool
    ) -> float:
        """Calculate confidence score for a finding.

        Args:
            code: Source code
            pattern: Exploit pattern
            match: Regex match object
            has_mitigation: Whether mitigation indicators were found

        Returns:
            Confidence score between 0.0 and 1.0
        """
        confidence = 0.7  # Base confidence

        # Reduce confidence if mitigation indicators present
        if has_mitigation:
            confidence -= 0.3

        # Increase confidence for critical patterns
        if pattern.severity == ExploitSeverity.CRITICAL:
            confidence += 0.1

        # Increase confidence if multiple pattern matches
        match_count = len(re.findall(pattern.patterns[0], code, re.IGNORECASE))
        if match_count > 1:
            confidence += 0.1

        return min(1.0, max(0.0, confidence))

    def _get_references(self, exploit_name: str) -> List[str]:
        """Get reference links for an exploit type.

        Args:
            exploit_name: Name of the exploit

        Returns:
            List of reference URLs
        """
        references = {
            "reentrancy": [
                "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/",
                "https://swcregistry.io/docs/SWC-107",
            ],
            "flash_loan_oracle_manipulation": [
                "https://www.paradigm.xyz/2020/11/so-you-want-to-use-a-price-oracle",
            ],
            "signature_replay": [
                "https://swcregistry.io/docs/SWC-121",
                "https://eips.ethereum.org/EIPS/eip-712",
            ],
            "uninitialized_proxy": [
                "https://blog.openzeppelin.com/security-advisories",
            ],
            "vault_share_inflation": [
                "https://blog.openzeppelin.com/a-]]novel-defense-against-erc4626-inflation-attacks",
            ],
        }
        return references.get(exploit_name, [])

    def get_severity_summary(self) -> Dict[ExploitSeverity, int]:
        """Get a summary of findings by severity.

        Returns:
            Dictionary mapping severity to count
        """
        summary: Dict[ExploitSeverity, int] = {s: 0 for s in ExploitSeverity}
        for finding in self.findings:
            summary[finding.severity] += 1
        return summary

    def get_category_summary(self) -> Dict[ExploitCategory, int]:
        """Get a summary of findings by category.

        Returns:
            Dictionary mapping category to count
        """
        summary: Dict[ExploitCategory, int] = {c: 0 for c in ExploitCategory}
        for finding in self.findings:
            summary[finding.category] += 1
        return summary

    def generate_report(self) -> str:
        """Generate a human-readable report of all findings.

        Returns:
            Formatted report string
        """
        if not self.findings:
            return "No economic exploits detected."

        report_lines = [
            "=" * 80,
            "ECONOMIC EXPLOIT DETECTION REPORT",
            "=" * 80,
            "",
            f"Total Findings: {len(self.findings)}",
            "",
            "Severity Summary:",
        ]

        for severity, count in self.get_severity_summary().items():
            if count > 0:
                report_lines.append(f"  - {severity.value.upper()}: {count}")

        report_lines.extend(["", "Category Summary:"])

        for category, count in self.get_category_summary().items():
            if count > 0:
                report_lines.append(f"  - {category.value}: {count}")

        report_lines.extend(["", "-" * 80, "DETAILED FINDINGS", "-" * 80, ""])

        for i, finding in enumerate(self.findings, 1):
            report_lines.extend(
                [
                    f"[{i}] {finding.exploit_type}",
                    f"    Severity: {finding.severity.value.upper()}",
                    f"    Category: {finding.category.value}",
                    f"    Location: {finding.location}",
                    f"    Confidence: {finding.confidence:.0%}",
                    f"    Description: {finding.description}",
                    f"    Potential Impact: {finding.potential_impact}",
                    f"    Mitigation: {finding.mitigation}",
                    "",
                    "    Code Snippet:",
                    "    " + "\n    ".join(finding.code_snippet.split("\n")),
                    "",
                ]
            )

        return "\n".join(report_lines)

    def to_json(self) -> List[Dict]:
        """Export findings as JSON-serializable list.

        Returns:
            List of finding dictionaries
        """
        return [
            {
                "exploit_type": f.exploit_type,
                "severity": f.severity.value,
                "category": f.category.value,
                "description": f.description,
                "location": f.location,
                "code_snippet": f.code_snippet,
                "confidence": f.confidence,
                "potential_impact": f.potential_impact,
                "mitigation": f.mitigation,
                "references": f.references,
            }
            for f in self.findings
        ]
